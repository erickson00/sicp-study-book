# 程序设计的基本元素

程序设计的基本元素:

1. 基本表达形式
2. 组合的方法
3. 抽象的方法

代码参考:[chapter1/1.1.rkt](https://github.com/erickson00/sicp-study-book/blob/master/docs/code/chapter1/1.1.rkt)

## 表达式

表达式的操作符前置(列表中第一个符号为操作符)如:

```lisp
(* 1 2)
(* 1 2 3)
```

## 命名和环境

关于命名:define

## 组合式的求值

过程的定义: (define (name paramters) body)

过程的组合: 过程可以相互组合

## 过程应用的代换模型

应用序(lisp中实际使用的): 先求值参数后应用

正则序:完全展开而后规约

应用序相对正则序会减少一些重复求值;另作者提到在一些情况下正则序也会成为有价值的工具,作者提到会在3、4章研究这个.

## 条件表达式和谓词

条件表达式:

```lisp
(cond (p1 r1)
  (p2 r2)
  (else r3))
```

```lisp
(if pridecate r1 r2)
```

逻辑符合运算符: and 、or、not

## 牛顿法求平方根

采用不断猜测结果的方法,直到猜测结果符合最终要求则返回猜测结果
有两个关键点:

1. 每一次新的猜测都要比前一次更接近正确结果
2. 判定猜测结果是否符合预期(数值计算运行一定的误差范围)

对于第一点示例中采用了: 例如求`x`的平方根,猜测值为`guess`,新的猜测结果为$$\frac{guess + (x/guess)}{2}$$

## 练习

### 练习1.6

定义一个new-if使用cond模拟if,用于替换`chapter1/1.1.rkt`中`sqrt`的`if`:

```lisp
(define (new-if a b c)
  (cond (a b)
        (else c)))
```

是否可以满足需求.

解答: 不满足,经实际执行后会发现程序会陷入死循环,分析之后可得出:
执行`new-if`会先对每一个参数求值结束后才执行`new-if`本身,由于第二个参数是个递归永远也不会结束.
lisp定义的`if`是个特殊过程会根据条件判断的结果决定计算哪部分参数,这点`new-if`是没有实现的.
更细致的分析要发挥自己的主观能动性去好好想想了.

### 练习1.7

由于我们刚开始定义的`good-enough?`是很不好的?不适合非常大的数的计算,举出例子说明对于很大或很小的数计算都有可能失败?
另一种策略是检测改进的值的变化情况,当改变的值相对于猜测值的比率很小时就结束,请根据描述设计平方根过程,新的方式对于很大
或很小的数都能工作吗?

解答: 先看之前的对`good-enough?`的定义`(< (abs (- (square guess) x)) 0.001)`,根据直觉基本可以做出以下判断:
初始时定义的求平方根的方法,对于很小的数比如0.00001肯定不能得出合理的结果,对于比较大的数会需要很大的计算量.
改进后的方法应该是可行的, `更小的数`允许的`直接相减误差值`应该是更小的,同理对于`更大的数`允许的`误差值`也该是更大的,
合理的`误差值`相对于猜测值的变化应该是线性的, 因此这里提出的方法应该是合理的.

### 练习1.8

根据改进猜测值的公式$$\frac{x/y^2 + 2y}{3}$$定义立方根

解答: 参考平方根方法,没什么好说的.

## 过程作为黑箱抽象

作者在这节中主要讲了要做适当的封装,避免暴露不必要的方法给外部,仅向外部暴露必要的接口,这个原则做过几年程序的都比较了解了,
没什么可说的,合适的封装层次/接口设计是考验程序基本功的很重要的方面,在这方面个人也要做出更大的努力,
我们关注下lisp为我们提供的`进行封装`/`环境隔离`/`将对应的过程、变常量放到合适的作用域`的方法:

块结构: 嵌套定义(在define中嵌套define)

练习: 结合本节内容改进求平方根过程的定义
